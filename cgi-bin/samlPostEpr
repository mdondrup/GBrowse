#!/usr/bin/env perl 

$| = 1; undef $/;  
use strict;
use warnings;
use Net::SAML;
use CGI::Cookie;
use CGI::Fast qw(:standard);
use Data::Dumper;
use Bio::Graphics::Browser2;
use Bio::Graphics::Browser2::Render::HTML;
use JSON;
my $DEBUG = 1;

## this is most likely only required for use with FastCGI
#
while (my $q = CGI::Fast->new) { # using mod_fcgid, afaik cannot avoid using this
    unless ($ENV{'REQUEST_METHOD'} eq 'POST') {
	die "this endpoint is for POST data only\n"; 
    };
    my $globals = Bio::Graphics::Browser2->open_globals;
    print (STDERR "should have read ".$ENV{'CONTENT_LENGTH'}."\n") if $DEBUG;
    
    #my $p = "https://lb-test.bccs.uib.no";
    my $myurl = $globals->gbrowse_url;
    my $htmlhead = <<HTML
<script src="/gbrowse2/js/login.js" type="text/javascript"></script>
<script src="/gbrowse2/js/controller.js" type="text/javascript"></script>
HTML
;
	
  my $url = url(-path_info=>1);
  my $conf = "PATH=/home/licebase/zxid/var/zxid/&URL=$url";
  my $cf = Net::SAML::new_conf_to_cf($conf);
  my $qs = $q->query_string(); # this is the only safe way to receive the post
  die "empty query string received" unless $qs;
  my $res = Net::SAML::simple_cf($cf, -1, $qs, undef, 0x1828);	  
  my $op = substr($res, 0, 1);
  if ($op ne 'd') { warn "Unknown Net::SAML reponse code: $res"; }
  
  my ($userid, $displayName, $email, $sid) = (_parse_saml($res, undef));
  my $sessionid;
  if ($userid && $sid) {
      my $globals = Bio::Graphics::Browser2->open_globals;
      my $userdb = Bio::Graphics::Browser2::UserDB->new($globals);
      my $session = $globals->session;
     
      $session->samlid($sid);
      $sessionid = $session->id;
      $session->username($userid);
      $session->flush();
      print STDERR $session->username. " stored in session ". $session->id if $DEBUG; 	
      my $confirmedUserId = $userdb->userid_from_username($userid);
      if ($confirmedUserId eq "") {
	  print STDERR "User $userid does not yet exist; will create.\n" if $DEBUG;
	  print STDERR "Flushed session.  Will now create user using session.\n" if $DEBUG;
	  my ($status,undef,$message) = $userdb->do_add_user($userid,$email,$displayName,'dummy-password',$sessionid);
	  print STDERR "Results from do_add_user: Status: $status\n" if $DEBUG;
	  print STDERR "Results from do_add_user: Message: $message\n" if $DEBUG;
	  $userdb->set_confirmed_from_username($userid);
	  print STDERR "User set as confirmed.\n" if $DEBUG;
	  $userdb->set_fullname_from_username($userid, $displayName, $email) if $displayName;
      } else {
	  print STDERR "Found existing user with ID: $confirmedUserId so skipping creation.\n" if $DEBUG;
      }
      my $id = $userdb->check_or_add_named_session($session->id,$userid);
     
      print STDERR "setting $userid, $displayName, $email, $id in UserDB \n" if $DEBUG;
      
      my $result = to_json { userOK  => 1,
			     sessionid => $sessionid,
			     username  => $userid,
			     message   => 'login ok',
			 };
     
      my $cookie = CGI::Cookie->new(-name => 'gbrowse_sess', 
				    -path => '/fgb2/',
				    
				    -value => $sessionid);
      print header(-type=>"text/html", -cookie=>$cookie);
      print start_html(-head=>$htmlhead);
     
      print script({-type=>'text/javascript'},
<<SCRIPT      
var p = $result;
login_load_account("$myurl", p);
SCRIPT
);
  } 

    print end_html();	
}

sub _parse_saml {
    my $saml = shift;
    my $mandatoryRole = shift;
    my ($sid) = $saml =~ /^sesid: (.*)$/m;
    return undef unless $sid;
    my %roles = map {$_,1} ($saml =~  m/^role:\s+(.+)$/mg);
    print STDERR join "\t", %roles;
    return undef if ($mandatoryRole && !$roles{$mandatoryRole});

    my ($uid) = $saml =~ m/^uid:\s+(.+)$/m;
    return undef unless $uid;
    
    my ($displayName) = $saml =~ m/^displayName:\s+(.+)$/m;
    my ($mail) = $saml =~ m/^mail:\s+(.+)$/m;
    return ($uid, $displayName, $mail, $sid);
}

__END__
